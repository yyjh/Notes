# 计算机中数的表示

数的表示：计算机中能直接被硬件识别和处理的数据类型，即计算机指令系统中有对这些数据类型进行操作的指令。

## 无符号数

整个机器字长的全部二进制位表示数值位， 相当于数的绝对值。

若机器字长为n位，则数值范围是0<= X<=2^n-1

## 有符号数

1. ### 真值和机器数

   **真值**:平时用的真实的值。

   **机器数**：将符号`数字化`的数，是数字在计算机中的二进制表示形式，符号位占有一位。带有符号位的机器数对应的数值称为机器数的真值。

   | 真值(带符号的数) | 机器数（符号数字化的数） | 小数点位置            |
   | ---------------- | ------------------------ | --------------------- |
   | +0.1011          | 0 1011                   | 符号位0后，数字位之前 |
   | -0.1011          | 1 1011                   | 符号位1后，数字位之前 |
   | +1100            | 01100                    | 数字末尾              |
   | -1100            | 11100                    | 数字末尾              |

   一个数字计算机中保存需要三部分内容：符号，小数点位置，数的数值位。计算机中没有专门的硬件表示小数点，小数点都是以约定的方式给出。对于小数，小数点约定在符号位后，对于证书，小数点约定在数值部分最后。定点计算机（小数点位置固定的计算机）分为两类，小数定点机好整数定点机。

2. ### 原码表示法

   1. #### 整数表示

      1. **正数**：将数据的符号位用0表示。为了使符号位用0表示，只需要在数值位的最高位添加0。可以理解为0 + 数值，比如1011，0000 0000 + 1011 = 0000 1011。
      2. **负数**: 将数据为的符号位用1表示。为了使符号位用1表示，只需要在真值绝对值的基础上加2^n。如-1011，即2^8 + 1011=1000 0000 + 1011=10001011。

   2. #### 小数表示

   3. #### 原码特点

      简单、直观的原码进行加减法运算时会出现如下问题：

      | 运算 | 数1  | 数2  | 实际操作 | 结果符号 |
      | ---- | ---- | ---- | -------- | -------- |
      | 加法 | 正   | 正   | 加       | 正       |
      | 加法 | 正   | 负   | 减法     | 可正可负 |
      | 加法 | 负   | 正   | 减法     | 可正可负 |
      | 加法 | 负   | 负   | 加       | 负       |

      同样的加法操作运算器实际操作可能是加法，也可能是减法，无法归一化。如果找到一个与负数等价的正数来代替负数，就可使得加负数和加这个正数的结果相同。即将减法操作转化为了加法操作。补码就是为了解决这一问题。

3. ### 补码表示 two's complement representation

   补码解决了加减法归一问题，且符号位与数值位统一处理。

   1. #### 补的概念

      时钟旋转问题。向前调n位相当于向后调12-n位。对于模12，

      (6 - 3)(mod12) = 3，相当于(6 + 9)(mod12) = (6 + 12 - 3）(mod12) =(6 - 3 + 12）(mod12)=3，也就是说可以用+9代替-3，把减法变成加法。这时候，我们称+9是-3以12为模的补数。

      补数有以下特点：

      1. 一个负数加上`模`即得该负数的补数。
      2. 一个正数和一个负数互为补数时，他们的绝对值之和即为模数。

      而计算机中数据存储设备类似时钟，当进行加法运算时，结果大于等于能存储的最大值（比如说256）时便会丢掉进位部分，类似于以最大值（256）为模。

      负数加模为其补数 -1011 + 10000 = +0101

      正数加模为其本身 0101 + 10000 = 0101（去掉首位）

      因此，正数的模为其本身。

   2. #### 补码定义

      **正数** 0 <= x <= 2^n，**补码** x，即其本身

      **负数**-2^n < x < 0，**补码**2^n+1 + x，即模 + 本身

   3. #### 补码快捷求法

      推导：

      x = -1010

      补=2^(4+1) - **1010** 	   = 11111 + 1  -1010

      ​    =100000  				  = 11111 + 1 

      ​	     -1010					    -1010

      ----------------------------   -----------------------------------

         =  1,0110                         **10101** + 1（原码取反加1）

      ​										= 1,0110

      原码**x=1,1010**

      **因此，当真值为负时，补码=原码除符号位外，每位取反，末位加1。**

   4. #### 补码到原码

      补码**1,0110**

      1. 定义推。

         补码为负，原码一定为负（因为正数的补码是其本身，也为正）。补 = 模 + 原码 = 模 - 原码绝对值=>原码绝对值 = 模 - 补

         码绝对值 = 模 - 补

         2^(4+1) - 10110		   = 11111 + 1 - 10110

         =100000						 = 11111 + 1

      ​		  10110						  -10110

      ------------------------------------------------------------------

      ​	    =     1010						 =   **1001** + 1(补码取反加1，即原码是**补码的补码**)

      加上符号即为1,1010						 1,1010

      2. 补码求法逆推。

         求补码的逆过程，末位减1为1,0101，每位取反1,1010。其实，减1取反等价于取反加1。

      **因此，原码等于补码每位取反，末位加1.**

4. ### 反码表示

   正数反码为其本身，负数反码表示为符号位不变，其余按位取反。

5. ### 移码表式法

   1. #### 定义

      移码 = 2^n + x，x为真值，n为正数的位数

   2. #### 特点

      1. 解决了补码难以判断真值大小的问题。
      2. 不管正负，转换移码都是加2^n。
      3. 只有正数形式，没有小数形式。移码用于表示浮点数据表示的阶码部分，阶码嗾使整数。

   

